import {
  DeleteObjectCommand,
  HeadObjectCommand,
  PutObjectCommand,
  S3Client,
} from '@aws-sdk/client-s3';
import { getSignedUrl } from '@aws-sdk/s3-request-presigner';
import {
  type MaybePromise,
  type Provider,
  type RequestUploadParams,
} from '@edgestore/shared';
import { v4 as uuidv4 } from 'uuid';
import { getEnv } from '../../adapters/shared';

// FileInfo type as received by the provider's requestUpload, part of RequestUploadParams
type ProviderUploadedFileInfo = RequestUploadParams['fileInfo'];

export type AWSOverwritePathFnArgs = {
  /* EdgeStore bucket name */
  esBucketName: string;
  /* File info after path generation and metadata by EdgeStore */
  fileInfo: ProviderUploadedFileInfo;
  /* The S3 key that would be generated by default by this provider */
  defaultAccessPath: string;
};

export type AWSOverwritePathFn = (
  args: AWSOverwritePathFnArgs,
) => MaybePromise<string>;

export type AWSProviderOptions = {
  /**
   * Access key for AWS credentials.
   * Can also be set via the `ES_AWS_ACCESS_KEY_ID` environment variable.
   *
   * If unset, the SDK will attempt to use the default credentials provider chain.
   */
  accessKeyId?: string;
  /**
   * Secret access key for AWS credentials.
   * Can also be set via the `ES_AWS_SECRET_ACCESS_KEY` environment variable.
   *
   * If unset, the SDK will attempt to use the default credentials provider chain.
   */
  secretAccessKey?: string;
  /**
   * AWS region to use.
   * Can also be set via the `ES_AWS_REGION` environment variable.
   */
  region?: string;
  /**
   * Name of the S3 bucket to use.
   * Can also be set via the `ES_AWS_BUCKET_NAME` environment variable.
   */
  bucketName?: string;
  /**
   * Custom endpoint for S3-compatible storage providers (e.g., MinIO).
   * Can also be set via the `ES_AWS_ENDPOINT` environment variable.
   */
  endpoint?: string;
  /**
   * Force path style for S3-compatible storage providers.
   * Can also be set via the `ES_AWS_FORCE_PATH_STYLE` environment variable.
   * Defaults to false for AWS S3, but should be true for most S3-compatible providers.
   */
  forcePathStyle?: boolean;
  /**
   * Base URL to use for accessing files.
   * Only needed if you are using a custom domain or cloudfront.
   *
   * It can also be set via the `EDGE_STORE_BASE_URL` environment variable.
   */
  baseUrl?: string;
  /**
   * Secret to use for encrypting JWT tokens.
   * Can be generated with `openssl rand -base64 32`.
   *
   * It can also be set via the `EDGE_STORE_JWT_SECRET` environment variable.
   */
  jwtSecret?: string;
  /**
   * Optional function to overwrite the S3 key (object path) for uploads.
   * This function receives the EdgeStore bucket name, fileInfo and the default S3 key
   * and should return the desired S3 key string.
   */
  overwritePath?: AWSOverwritePathFn;
};

export function AWSProvider(options?: AWSProviderOptions): Provider {
  const {
    accessKeyId = getEnv('ES_AWS_ACCESS_KEY_ID'),
    secretAccessKey = getEnv('ES_AWS_SECRET_ACCESS_KEY'),
    region = getEnv('ES_AWS_REGION'),
    bucketName = getEnv('ES_AWS_BUCKET_NAME'),
    endpoint = getEnv('ES_AWS_ENDPOINT'),
    forcePathStyle = getEnv('ES_AWS_FORCE_PATH_STYLE') === 'true',
    overwritePath,
  } = options ?? {};

  const baseUrl =
    options?.baseUrl ??
    getEnv('EDGE_STORE_BASE_URL') ??
    (endpoint
      ? `${endpoint}/${bucketName}`
      : `https://${bucketName}.s3.${region}.amazonaws.com`);

  const credentials =
    accessKeyId && secretAccessKey
      ? {
          accessKeyId,
          secretAccessKey,
        }
      : undefined;
  const s3Client = new S3Client({
    region,
    credentials,
    endpoint,
    forcePathStyle,
  });

  return {
    async init() {
      return {};
    },
    getBaseUrl() {
      return baseUrl;
    },
    async getFile({ url }) {
      const path = url.replace(`${baseUrl}/`, '');
      const { ContentLength, LastModified } = await s3Client.send(
        new HeadObjectCommand({
          Bucket: bucketName,
          Key: path,
        }),
      );

      if (!ContentLength || !LastModified) {
        throw new Error('File not found');
      }

      return {
        url,
        metadata: {},
        path: {},
        size: ContentLength,
        uploadedAt: LastModified,
      };
    },
    async requestUpload(params: RequestUploadParams) {
      const { bucketName: esBucketName, fileInfo } = params;

      if (!bucketName) {
        throw new Error(
          'S3 bucketName is not configured in AWSProviderOptions.',
        );
      }

      // Default S3 key (accessPath) construction logic
      const pathPrefix = `${esBucketName}${
        fileInfo.isPublic ? '/_public' : ''
      }`;
      const nameId = uuidv4();
      const extension = fileInfo.extension
        ? `.${fileInfo.extension.replace('.', '')}`
        : '';
      const defaultResolvedFileName =
        fileInfo.fileName ?? `${nameId}${extension}`;
      const defaultFilePathFromMetadata = fileInfo.path.reduce((acc, item) => {
        return `${acc}/${item.value}`;
      }, '');

      let accessPath = `${pathPrefix}${defaultFilePathFromMetadata}/${defaultResolvedFileName}`;

      if (overwritePath) {
        accessPath = await overwritePath({
          esBucketName,
          fileInfo,
          defaultAccessPath: accessPath,
        });
      }

      const command = new PutObjectCommand({
        Bucket: bucketName,
        Key: accessPath,
      });

      const signedUrl = await getSignedUrl(s3Client, command, {
        expiresIn: 60 * 60, // 1 hour
      });

      const finalAccessUrl = `${baseUrl}/${accessPath.startsWith('/') ? accessPath.substring(1) : accessPath}`;
      return {
        uploadUrl: signedUrl,
        accessUrl: finalAccessUrl,
      };
    },
    async requestUploadParts() {
      throw new Error('Not implemented');
    },
    async completeMultipartUpload() {
      throw new Error('Not implemented');
    },
    async confirmUpload() {
      throw new Error('Not implemented');
    },
    async deleteFile({ url }) {
      if (!bucketName) {
        throw new Error(
          'S3 bucketName is not configured in AWSProviderOptions for deleteFile.',
        );
      }
      const path = url.replace(`${baseUrl}/`, '');
      await s3Client.send(
        new DeleteObjectCommand({
          Bucket: bucketName,
          Key: path,
        }),
      );
      return {
        success: true,
      };
    },
  };
}
